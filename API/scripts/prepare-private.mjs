import fs from "fs/promises";
import path from "path";

let projectRoot = path.resolve(path.dirname(new URL(import.meta.url).pathname), "..");
if (path.basename(projectRoot) === "API") {
  projectRoot = path.resolve(projectRoot, "..");
}
const privateRoot = path.join(projectRoot, "Private");
const billingRootSibling = path.resolve(projectRoot, "..", "Billing");
const billingRootLocal = path.resolve(projectRoot, "Billing");
const moduleRoots = [privateRoot, billingRootSibling, billingRootLocal];
const apiPrivateDir = path.join(projectRoot, "API", "Private");

const apiRegistryPath = path.join(projectRoot, "API", "src", "private", "registry.ts");
const apiTypesPath = path.join(projectRoot, "API", "src", "private", "private-modules.generated.d.ts");
const adminRoutesPath = path.join(projectRoot, "Admin", "src", "private", "routes.generated.tsx");
const generatedPrismaDir = path.join(projectRoot, "API", "prisma", "generated");

const exists = async (target) => {
  try {
    await fs.access(target);
    return true;
  } catch {
    return false;
  }
};

const toPosixImport = (fromFile, targetFile) => {
  const rel = path.relative(path.dirname(fromFile), targetFile);
  const normalized = rel.split(path.sep).join("/");
  return normalized.startsWith(".") ? normalized : `./${normalized}`;
};

const manifestFileForDir = async (dir) => {
  const pluginManifest = path.join(dir, "plugin.manifest.json");
  if (await exists(pluginManifest)) return pluginManifest;
  const privateManifest = path.join(dir, "private.manifest.json");
  if (await exists(privateManifest)) return privateManifest;
  return null;
};

const collectModulesFromRoot = async (rootDir) => {
  if (!(await exists(rootDir))) return [];
  const manifestPath = await manifestFileForDir(rootDir);
  if (manifestPath) {
    return [{ dir: rootDir, manifestPath }];
  }
  const entries = await fs.readdir(rootDir, { withFileTypes: true });
  const modules = [];
  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    const moduleDir = path.join(rootDir, entry.name);
    const moduleManifest = await manifestFileForDir(moduleDir);
    if (!moduleManifest) continue;
    modules.push({ dir: moduleDir, manifestPath: moduleManifest });
  }
  return modules;
};

const readManifests = async () => {
  const manifestEntries = [];
  for (const root of moduleRoots) {
    const entries = await collectModulesFromRoot(root);
    manifestEntries.push(...entries);
  }

  const manifestsById = new Map();
  for (const entry of manifestEntries) {
    const raw = JSON.parse(await fs.readFile(entry.manifestPath, "utf8"));
    const id = raw.id ?? path.basename(entry.dir);
    const routePath = raw.ui?.routePath;
    const menuLabel = raw.ui?.menu?.label ?? raw.name ?? id;
    const navId = (raw.ui?.menu?.id ?? (routePath ? routePath.replace(/^\//, "") : id)) || id;
    const module = {
      id,
      name: raw.name ?? id,
      dir: entry.dir,
      apiEntry: raw.api?.entry ? path.resolve(entry.dir, raw.api.entry) : null,
      ui: raw.ui && raw.ui.component && raw.ui.routePath
        ? {
            component: path.resolve(entry.dir, raw.ui.component),
            routePath: raw.ui.routePath,
            navId,
            menuLabel,
            menuIcon: raw.ui.menu?.icon ?? "apps",
            page: {
              title: raw.ui.page?.title ?? menuLabel,
              breadcrumbs: raw.ui.page?.breadcrumbs ?? [{ label: menuLabel }],
              actions: raw.ui.page?.actions ?? [],
            },
          }
        : null,
      db: raw.db?.schema
        ? {
            schema: path.resolve(entry.dir, raw.db.schema),
            migrations: raw.db.migrations ? path.resolve(entry.dir, raw.db.migrations) : null,
          }
        : null,
    };
    if (!manifestsById.has(id)) {
      manifestsById.set(id, module);
    }
  }

  return Array.from(manifestsById.values()).sort((a, b) => a.id.localeCompare(b.id));
};

const writeIfChanged = async (target, content) => {
  const current = (await exists(target)) ? await fs.readFile(target, "utf8") : null;
  if (current === content) return;
  await fs.mkdir(path.dirname(target), { recursive: true });
  await fs.writeFile(target, content, "utf8");
};

const generateApiRegistry = async (modules) => {
  const withApi = modules.filter((m) => m.apiEntry);
  const imports = withApi
    .map((mod, idx) => `import * as module${idx} from "${toPosixImport(apiRegistryPath, mod.apiEntry)}";`)
    .join("\n");
  const entries = withApi
    .map(
      (mod, idx) =>
        `  { id: "${mod.id}", register: (module${idx} as any).register ?? (module${idx} as any).default },`,
    )
    .join("\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    'import type { PrivateApiPlugin } from "./types.js";',
    imports,
    "",
    "export const privateApiPlugins: PrivateApiPlugin[] = [",
    entries,
    "];",
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(apiRegistryPath, content);
};

const generateApiTypes = async (modules) => {
  const withApi = modules.filter((m) => m.apiEntry);
  const declarations = withApi
    .map((mod) => {
      const importPath = toPosixImport(apiTypesPath, mod.apiEntry);
      return [
        `declare module "${importPath}" {`,
        '  import type { FastifyInstance } from "fastify";',
        '  import type { PrivateApiPluginDeps } from "./types.js";',
        "  export function register(app: FastifyInstance, deps: PrivateApiPluginDeps): Promise<void> | void;",
        "  const _default: typeof register;",
        "  export default _default;",
        "}",
      ].join("\n");
    })
    .join("\n\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    declarations,
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(apiTypesPath, content);

  const apiTypesImport = path.join(projectRoot, "API", "src", "private", "types.js");
  for (const mod of withApi) {
    const parsed = path.parse(mod.apiEntry);
    const declarationPath = path.join(parsed.dir, `${parsed.name}.d.ts`);
    const relTypesImport = toPosixImport(declarationPath, apiTypesImport);
    const moduleContent = [
      "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
      'import type { FastifyInstance } from "fastify";',
      `import type { PrivateApiPluginDeps } from "${relTypesImport}";`,
      "export function register(app: FastifyInstance, deps: PrivateApiPluginDeps): Promise<void> | void;",
      "const _default: typeof register;",
      "export default _default;",
      "",
    ].join("\n");
    await writeIfChanged(declarationPath, moduleContent);
  }
};

const generateAdminRoutes = async (modules) => {
  const withUi = modules.filter((m) => m.ui);
  const componentDecls = withUi
    .map(
      (mod, idx) =>
        `const Module${idx} = lazy(() => import("${toPosixImport(adminRoutesPath, mod.ui.component)}"));`,
    )
    .join("\n");
  const navItems = withUi
    .map(
      (mod) =>
        `  { id: "${mod.ui.navId}", label: "${mod.ui.menuLabel}", icon: "${mod.ui.menuIcon}" },`,
    )
    .join("\n");
  const routes = withUi
    .map(
      (mod, idx) =>
        `  { id: "${mod.ui.navId}", path: "${mod.ui.routePath}", element: <Module${idx} />, navId: "${mod.ui.navId}" },`,
    )
    .join("\n");
  const pages = withUi
    .map(
      (mod) =>
        `  "${mod.ui.navId}": { title: "${mod.ui.page.title}", breadcrumbs: ${JSON.stringify(
          mod.ui.page.breadcrumbs,
        )}, actions: ${JSON.stringify(mod.ui.page.actions)} },`,
    )
    .join("\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    'import { lazy } from "react";',
    'import type { NavItemConfig, PageConfigEntry, RouteConfig } from "../routes/config";',
    componentDecls,
    "",
    "export const privateNavItems: NavItemConfig[] = [",
    navItems,
    "];",
    "",
    "export const privateRoutes: RouteConfig[] = [",
    routes,
    "];",
    "",
    "export const privatePageConfig: Record<string, PageConfigEntry> = {",
    pages,
    "};",
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(adminRoutesPath, content);
};

const copyDir = async (source, destination) => {
  await fs.mkdir(destination, { recursive: true });
  await fs.cp(source, destination, { recursive: true, force: true });
};

const syncApiPrivateDir = async (modules) => {
  const apiModules = modules.filter((mod) => mod.apiEntry);
  if (!apiModules.length) return [];

  await fs.rm(apiPrivateDir, { recursive: true, force: true });

  const synced = [];
  for (const mod of apiModules) {
    const targetDir = path.join(apiPrivateDir, mod.id);
    await copyDir(mod.dir, targetDir);
    const entryRel = mod.apiEntry ? path.relative(mod.dir, mod.apiEntry) : null;
    synced.push({
      ...mod,
      apiEntry: entryRel ? path.join(targetDir, entryRel) : null,
    });
  }
  return synced;
};

const extractSchemaInjects = (schemaContent) => {
  const injectPattern = /\/\/\s*@inject\s+([A-Za-z0-9_]+)\s*\n([\s\S]*?)\/\/\s*@endinject/g;
  const injects = [];
  let match;
  while ((match = injectPattern.exec(schemaContent)) !== null) {
    injects.push({
      model: match[1],
      body: match[2],
    });
  }
  const withoutInjects = schemaContent.replace(injectPattern, "").trim();
  return { injects, schema: withoutInjects };
};

const applySchemaInjects = (schemaContent, injects) => {
  let nextSchema = schemaContent;
  for (const inject of injects) {
    const trimmed = inject.body
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.length > 0)
      .join("\n");
    if (!trimmed) continue;
    const indented = trimmed
      .split("\n")
      .map((line) => `  ${line}`)
      .join("\n");
    const modelPattern = new RegExp(`model\\s+${inject.model}\\s*\\{([\\s\\S]*?)\\n\\}`, "m");
    if (!modelPattern.test(nextSchema)) {
      throw new Error(`Unable to inject schema for missing model: ${inject.model}`);
    }
    nextSchema = nextSchema.replace(modelPattern, (match, body) => {
      const suffix = body.endsWith("\n") ? "" : "\n";
      return `model ${inject.model} {${body}${suffix}${indented}\n}`;
    });
  }
  return nextSchema;
};

const generatePrismaArtifacts = async (modules) => {
  const baseSchemaPath = path.join(projectRoot, "API", "prisma", "schema.prisma");
  const baseMigrationsDir = path.join(projectRoot, "API", "prisma", "migrations");

  const schemaInjects = [];
  let baseSchema = await fs.readFile(baseSchemaPath, "utf8");
  for (const mod of modules) {
    if (!mod.db?.schema) continue;
    const fragment = await fs.readFile(mod.db.schema, "utf8");
    if (/^\s*(generator|datasource)\s+/m.test(fragment)) {
      throw new Error(`Private module ${mod.id} schema must not declare generator/datasource`);
    }
    const { injects, schema } = extractSchemaInjects(fragment);
    if (injects.length) {
      schemaInjects.push(...injects);
    }
    if (schema.trim()) {
      baseSchema += `\n// ---- Private schema: ${mod.id} ----\n${schema}\n`;
    }
  }

  if (schemaInjects.length) {
    const directInjects = schemaInjects.filter((inject) => inject.model);
    baseSchema = applySchemaInjects(baseSchema, directInjects);
  }

  await fs.rm(generatedPrismaDir, { recursive: true, force: true });
  await fs.mkdir(path.join(generatedPrismaDir, "migrations"), { recursive: true });
  await writeIfChanged(path.join(generatedPrismaDir, "schema.prisma"), baseSchema);

  if (await exists(baseMigrationsDir)) {
    await copyDir(baseMigrationsDir, path.join(generatedPrismaDir, "migrations"));
  }

  for (const mod of modules) {
    if (!mod.db?.migrations || !(await exists(mod.db.migrations))) continue;
    const entries = await fs.readdir(mod.db.migrations, { withFileTypes: true });
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      const targetDir = path.join(
        generatedPrismaDir,
        "migrations",
        `pvt-${mod.id}-${entry.name}`,
      );
      await copyDir(path.join(mod.db.migrations, entry.name), targetDir);
    }
  }
};

const main = async () => {
  const manifests = await readManifests();
  const syncedModules = await syncApiPrivateDir(manifests);
  await generateApiRegistry(syncedModules);
  await generateApiTypes(syncedModules);
  await generateAdminRoutes(manifests);
  await generatePrismaArtifacts(manifests);
};

await main();
