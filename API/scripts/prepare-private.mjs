import fs from "fs/promises";
import path from "path";

const projectRoot = path.resolve(path.dirname(new URL(import.meta.url).pathname), "..", "..");
const privateRoot = path.join(projectRoot, "Private");
const apiPrivateDir = path.join(projectRoot, "API", "Private");

const apiRegistryPath = path.join(projectRoot, "API", "src", "private", "registry.ts");
const apiTypesPath = path.join(projectRoot, "API", "src", "private", "private-modules.generated.d.ts");
const adminRoutesPath = path.join(projectRoot, "Admin", "src", "private", "routes.generated.tsx");
const generatedPrismaDir = path.join(projectRoot, "API", "prisma", "generated");

const exists = async (target) => {
  try {
    await fs.access(target);
    return true;
  } catch {
    return false;
  }
};

const toPosixImport = (fromFile, targetFile) => {
  const rel = path.relative(path.dirname(fromFile), targetFile);
  const normalized = rel.split(path.sep).join("/");
  return normalized.startsWith(".") ? normalized : `./${normalized}`;
};

const readManifests = async () => {
  if (!(await exists(privateRoot))) return [];
  const entries = await fs.readdir(privateRoot, { withFileTypes: true });
  const manifests = [];
  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    const moduleDir = path.join(privateRoot, entry.name);
    const manifestPath = path.join(moduleDir, "private.manifest.json");
    if (!(await exists(manifestPath))) continue;
    const raw = JSON.parse(await fs.readFile(manifestPath, "utf8"));
    const id = raw.id ?? entry.name;
    const routePath = raw.ui?.routePath;
    const menuLabel = raw.ui?.menu?.label ?? raw.name ?? id;
    const navId = (raw.ui?.menu?.id ?? (routePath ? routePath.replace(/^\//, "") : id)) || id;
    const module = {
      id,
      name: raw.name ?? id,
      dir: moduleDir,
      apiEntry: raw.api?.entry ? path.resolve(moduleDir, raw.api.entry) : null,
      ui: raw.ui && raw.ui.component && raw.ui.routePath
        ? {
            component: path.resolve(moduleDir, raw.ui.component),
            routePath: raw.ui.routePath,
            navId,
            menuLabel,
            menuIcon: raw.ui.menu?.icon ?? "apps",
            page: {
              title: raw.ui.page?.title ?? menuLabel,
              breadcrumbs: raw.ui.page?.breadcrumbs ?? [{ label: menuLabel }],
              actions: raw.ui.page?.actions ?? [],
            },
          }
        : null,
      db: raw.db?.schema
        ? {
            schema: path.resolve(moduleDir, raw.db.schema),
            migrations: raw.db.migrations ? path.resolve(moduleDir, raw.db.migrations) : null,
          }
        : null,
    };
    manifests.push(module);
  }
  return manifests.sort((a, b) => a.id.localeCompare(b.id));
};

const writeIfChanged = async (target, content) => {
  const current = (await exists(target)) ? await fs.readFile(target, "utf8") : null;
  if (current === content) return;
  await fs.mkdir(path.dirname(target), { recursive: true });
  await fs.writeFile(target, content, "utf8");
};

const generateApiRegistry = async (modules) => {
  const withApi = modules.filter((m) => m.apiEntry);
  const imports = withApi
    .map((mod, idx) => `import * as module${idx} from "${toPosixImport(apiRegistryPath, mod.apiEntry)}";`)
    .join("\n");
  const entries = withApi
    .map(
      (mod, idx) =>
        `  { id: "${mod.id}", register: (module${idx} as any).register ?? (module${idx} as any).default },`,
    )
    .join("\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    'import type { PrivateApiPlugin } from "./types.js";',
    imports,
    "",
    "export const privateApiPlugins: PrivateApiPlugin[] = [",
    entries,
    "];",
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(apiRegistryPath, content);
};

const generateApiTypes = async (modules) => {
  const withApi = modules.filter((m) => m.apiEntry);
  const declarations = withApi
    .map((mod) => {
      const importPath = toPosixImport(apiTypesPath, mod.apiEntry);
      return [
        `declare module "${importPath}" {`,
        '  import type { FastifyInstance } from "fastify";',
        '  import type { PrivateApiPluginDeps } from "./types.js";',
        "  export function register(app: FastifyInstance, deps: PrivateApiPluginDeps): Promise<void> | void;",
        "  const _default: typeof register;",
        "  export default _default;",
        "}",
      ].join("\n");
    })
    .join("\n\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    declarations,
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(apiTypesPath, content);

  const apiTypesImport = path.join(projectRoot, "API", "src", "private", "types.js");
  for (const mod of withApi) {
    const parsed = path.parse(mod.apiEntry);
    const declarationPath = path.join(parsed.dir, `${parsed.name}.d.ts`);
    const relTypesImport = toPosixImport(declarationPath, apiTypesImport);
    const moduleContent = [
      "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
      'import type { FastifyInstance } from "fastify";',
      `import type { PrivateApiPluginDeps } from "${relTypesImport}";`,
      "export function register(app: FastifyInstance, deps: PrivateApiPluginDeps): Promise<void> | void;",
      "const _default: typeof register;",
      "export default _default;",
      "",
    ].join("\n");
    await writeIfChanged(declarationPath, moduleContent);
  }
};

const generateAdminRoutes = async (modules) => {
  const withUi = modules.filter((m) => m.ui);
  const componentDecls = withUi
    .map(
      (mod, idx) =>
        `const Module${idx} = lazy(() => import("${toPosixImport(adminRoutesPath, mod.ui.component)}"));`,
    )
    .join("\n");
  const navItems = withUi
    .map(
      (mod) =>
        `  { id: "${mod.ui.navId}", label: "${mod.ui.menuLabel}", icon: "${mod.ui.menuIcon}" },`,
    )
    .join("\n");
  const routes = withUi
    .map(
      (mod, idx) =>
        `  { id: "${mod.ui.navId}", path: "${mod.ui.routePath}", element: <Module${idx} />, navId: "${mod.ui.navId}" },`,
    )
    .join("\n");
  const pages = withUi
    .map(
      (mod) =>
        `  "${mod.ui.navId}": { title: "${mod.ui.page.title}", breadcrumbs: ${JSON.stringify(
          mod.ui.page.breadcrumbs,
        )}, actions: ${JSON.stringify(mod.ui.page.actions)} },`,
    )
    .join("\n");

  const content = [
    "// Auto-generated by scripts/prepare-private.mjs. Do not edit by hand.",
    'import { lazy } from "react";',
    'import type { NavItemConfig, PageConfigEntry, RouteConfig } from "../routes/config";',
    componentDecls,
    "",
    "export const privateNavItems: NavItemConfig[] = [",
    navItems,
    "];",
    "",
    "export const privateRoutes: RouteConfig[] = [",
    routes,
    "];",
    "",
    "export const privatePageConfig: Record<string, PageConfigEntry> = {",
    pages,
    "};",
    "",
  ]
    .filter(Boolean)
    .join("\n");

  await writeIfChanged(adminRoutesPath, content);
};

const copyDir = async (source, destination) => {
  await fs.mkdir(destination, { recursive: true });
  await fs.cp(source, destination, { recursive: true, force: true });
};

const syncApiPrivateDir = async (modules) => {
  if (!modules.length) return [];

  await fs.rm(apiPrivateDir, { recursive: true, force: true });

  const synced = [];
  for (const mod of modules) {
    const targetDir = path.join(apiPrivateDir, mod.id);
    await copyDir(mod.dir, targetDir);
    const entryRel = mod.apiEntry ? path.relative(mod.dir, mod.apiEntry) : null;
    synced.push({
      ...mod,
      apiEntry: entryRel ? path.join(targetDir, entryRel) : null,
    });
  }
  return synced;
};

const generatePrismaArtifacts = async (modules) => {
  const baseSchemaPath = path.join(projectRoot, "API", "prisma", "schema.prisma");
  const baseMigrationsDir = path.join(projectRoot, "API", "prisma", "migrations");

  const schemaParts = [await fs.readFile(baseSchemaPath, "utf8")];
  for (const mod of modules) {
    if (!mod.db?.schema) continue;
    const fragment = await fs.readFile(mod.db.schema, "utf8");
    if (/^\s*(generator|datasource)\s+/m.test(fragment)) {
      throw new Error(`Private module ${mod.id} schema must not declare generator/datasource`);
    }
    schemaParts.push(`\n// ---- Private schema: ${mod.id} ----\n${fragment}\n`);
  }

  await fs.rm(generatedPrismaDir, { recursive: true, force: true });
  await fs.mkdir(path.join(generatedPrismaDir, "migrations"), { recursive: true });
  await writeIfChanged(path.join(generatedPrismaDir, "schema.prisma"), schemaParts.join("\n"));

  if (await exists(baseMigrationsDir)) {
    await copyDir(baseMigrationsDir, path.join(generatedPrismaDir, "migrations"));
  }

  for (const mod of modules) {
    if (!mod.db?.migrations || !(await exists(mod.db.migrations))) continue;
    const entries = await fs.readdir(mod.db.migrations, { withFileTypes: true });
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      const targetDir = path.join(
        generatedPrismaDir,
        "migrations",
        `pvt-${mod.id}-${entry.name}`,
      );
      await copyDir(path.join(mod.db.migrations, entry.name), targetDir);
    }
  }
};

const main = async () => {
  const manifests = await readManifests();
  const syncedModules = await syncApiPrivateDir(manifests);
  await generateApiRegistry(syncedModules);
  await generateApiTypes(syncedModules);
  await generateAdminRoutes(manifests);
  await generatePrismaArtifacts(manifests);
};

await main();
